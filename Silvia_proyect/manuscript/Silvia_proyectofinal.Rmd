---
title: "Proyecto Final"
author: "Silvia Chaves-Ramírez"
date:  "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_depth: 4
    toc_float: yes
    df_print: paged
bibliography: library.bib   
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Pregunta de investigación

¿El tamaño de los ámbitos de descanso de los grupos  *Thyroptera tricolor*  esta infuenciado por el tamaño del grupo y/o el número de hojas disponibles para refugiarse ?  
## Contexto  

*Thyroptera tricolor* es una  especie de murciélago que forma grupos sociales para refugiarse. Ésta especie utiliza hojas tubulares en crecimiento del orden zingiberales como refugio, y al ser éste un recurso efímero,sus ocupantes deben a buscar un nuevo refugio diariamente. Estudios anteriores han demostrado que los grupos de *T.tricolor* mantienen pequeños ámbitos de descanso con alta disponibilidad de refugios [@Vonhof2004]. Sin embargo se desconoce como varan en tamaño los ámbitos de descanso según el número de individuosque comforman cada grupo.

Para este  proyecto de investigación  voy a simular la ubicación espacial  para diferentes grupos sociales de *T. tricolor*, así como las ubicaciónes  de hojas disponibles que puedan ser usadas como refugios. Luego voy a estimar los ámbitos de descanso para diferentes grupos, además  determinaré la distribución y abundancia de refugios disponibles para cada grupo.Por último  voy aplicar un modelo lineal para determinar el efecto del tamaño del grupo sobre el tamaño de los ámbitos de descanso. 

# Hipótesis  y  predicciones 

*Thyroptera tricolor* podría ser una especie territorial, debido a que  los grupos  mantienen poca superposición entre sus ámbitos de descanso.
Los grupos más numerosos de *T.tricolo*,ocupan ámbitos de descanso  más grandes y con mayor cantidad de recursos, ya que al ser más numerosos pueden defender mejor  un área.

**Predicción I:** Entre más grande sea el grupo mayor será el ámbito de descanso y mayor la cantidad de refugios en el mismo.

**Predicción II:**  A densidades intermedias de refugios en el ambiente, los grupos de *T. tricolor* presentarán poca superposición de ámbitos de descanso 
### Determinación de Ámbitos de descanso


#
Para obtener los ámbitos de descanso  para  cada grupo de murciélagos, voy a aplicar el método de Estimación de densidad de Kernel  del paquete “aldeHabitatHR”  de R.
Utilizaré la función  'r kernelUD' 

Voy a usar la opción  “plotLSCV” que emplea el método de validación cruzada de mínimos cuadrados para encontrar el mejor valor suavizado del ancho de banda (argumento “h”), para  un kernel normal bivariado.

Porcentaje de superposición entre ámbitos de descanso (%SAD)
Cuando el 50 % del UD  de un grupo  esta superpuesto con el UD de otro grupo


### Tamaño Grupo vs Tamaño del Ámbito de descanso 

primer modelo voy a usar como variable respuesta el tamaño de ámbito de descanso y como variable fija el tamaño del grupo y como variable aleatoria la identidad del grupo

segundo modelo voy a usar como variable respuesta el porcentaje de superposición de ámbitos de descanso  y como variable fija el tamaño del grupo y como variable aleatoria la identidad del grupo. 

### Disponibilidad de refugios 

Voy a medir y comparar la densidad de refugios disponibles diariamente para cada grupo según su tamaño. 

Útilizare como variable fija el tamaño del grupo y como variable aleatoria la identidad del grupo.
(Densidad de hojas ~  Tamaño del grupo + identidad del grupo (variable aleatoria))



Cuarto modelo Voy a comparar el efecto de la densidad de refugios en el porcentaje de superposición de ámbitos de descanso entre los grupos. Para a aplicar un modelo lineal mixto generalizado , utilizando  el paquete  estadístico “glmm”  de R. Tomaré  como variable dependiente el porcentaje de superposición de ámbitos de descanso, mientras que las variables independientes serán el tamaño de los grupos y la identidad de los grupos, utilizando esta última como una variable aleatoria y utilizaré la densidad de refugios como la covariable del modelo


# Diagrama causal 
```{r}
# install_github("jtextor/dagitty/r")
require(dagitty)

# install.packages("ggdag")
require(ggdag)

# install.packages("wesanderson")
require(wesanderson)

## Representación de  diagrama causal  

#Quiero conocer el efecto de la disponibilidad  de refugios(H) sobre el tamaño de los ámbitos de descanso de los grupos de Thyroptera tricolor (AD) entre los grupos de Thyroptera tricolor, pero también deseo saber si  estos  varian segun el tamaño del grupo. 

#Modelo con un DAG:
  
# x = H
# z = TG
# y = AD

# Crear DAG
dag1 <- dagify(AD ~ TG,
                   AD~ H,
                   exposure = "TG",
                   outcome = "AD")

# compactar
tidy_dagitty(dag1)
```


```{r, echo=FALSE, fig.align='center'}
# graficar  
ggdag(dag1, layout = "circle") + theme_dag() 

# No  existe un flujo de información  entré el tamaño del grupo y la densidad  de hojas disponibles , por lo que no es necesario controlar  

```

# Código de  simulación 


### Simulación de hábitat para grupos de *T.tricolor*. **
 
Para simular datos aleatorios que similares al patrón  de distribución de hojas disponibles como refugios y las ubicaciones  de grupos de *T.tricolor*  observado en la naturaleza, apliqué un movimiento Browniano estandar, como se detalla a continuación:

```{r}
# Se cargan los paquetes necesarios para los análisis  

library(adehabitatHR) # Home Range Estimation 
library(ggplot2)

```
 
Funciones:

Simulación de Hábitat  

```{r Habitat}
#En esta función  es para generar las hojas disponibles como refugios dentro de  un área de 200 x 300 m2. También crean las variables para el número de grupos,  número de individuos por grupo   

sim_habitat <- function(n_groups, n_indiv, n_leaves = 3000, steps = 10000, sig2 = 0.7, plot = TRUE, xlim = c(0, 300), ylim = c(0, 200)) {


  if (n_leaves >= steps){
    cat(crayon::green(' Alto ahí, no se puede tener más hojas que steps\n'))
  stop()
}
  
t <- 0:steps  # Saltos de tiempo  en el que varia la distribución de hojas en el espacio

## Primero, se crea un set simulación de desviaciones con σ2= 0.7, para los valores de x
x <- rnorm(n = length(t) - 1, sd = sqrt(sig2))

## Ahora se  calcula la suma acumulada de las desviaciones 
cx <- c(0, cumsum(x))
 plot(t, cx, type = "l", ylim = range(cx))

## Se repiten los dos pasos anteriores para los valores de y
y <- rnorm(n = length(t) - 1, sd = sqrt(sig2))
## suma acumulada de las desviaciones para valores de y
cy <- c(0, cumsum(y))

# Simulación de hojas disponibles como refugios

sel_positions_x <- cumsum((rbinom(n_leaves, size = 2, prob = 0.1) * 400) + 50)
sel_positions_y <- cumsum((rbinom(n_leaves, size = 2, prob = 0.1) * 400) + 50)

sel_positions_x <- (sel_positions_x / max(sel_positions_x)) * steps
sel_positions_y <- (sel_positions_y / max(sel_positions_y)) * steps

slxs <- cx[sel_positions_x]
slys <- cy[sel_positions_y]

# Obtenemos las coordenadas  para el número de hojas disponibles como refugio dentro de los limites del área de estudio  200 x300 m2
slxs <- slxs + abs(min(slxs))
slxs <- (slxs / max(slxs)) * xlim[2]
slys <- slys + abs(min(slys))
slys <- (slys / max(slys)) * ylim[2]

# Se guardan las coordenadas de las hojas en  un data frame
coor_df <- data.frame(lon= slxs, lat = slys)

if (plot)
plot(coor_df$lon, coor_df$lat, pch = 20, col = adjustcolor("green", alpha.f = 0.3), xlim = xlim + c(-10, 10), ylim = ylim + c(-10, 10))


return() ## coor_df
}

```
 
Simulación ubicación de grupos 
```{r}
# Simular las coordenadas de ubicación para 10 grupos de murciélagos 
ubi_groups <- function(leaf_coors, groups, radius_constant = 6){
  
    if (groups >= nrow(leaf_coors)){
    cat(crayon::green('No se puede tener más grupos q hojas \n'))
  stop()
}
# Determinamos el tamaño  para los 10 grupos, usamos una probabilidaded 0.6 para que los tamaños de grupo tengan  sentido según lo visto  en la naturaleza  
  
  group_sizes <- rbinom(n = groups, 10, prob = 0.6)
  
# extraemos una hoja central para cada grupo  
  leaves <- sample(1:nrow(leaf_coors), length(group_sizes))
# obtenemos  las coordenanadas para cada hoja central 
  centers <- leaf_coors[leaves, ]  
  
  centers$group_size <- group_sizes

  centers$leaves <- leaves # todas  estas hojas pertencen al los ambitos de  descanso de  un grupo.
  
# Se calculan todas las distancias posibles entre la hoja central  mediante una matriz de distancia  entre las hojas disponibles.
  dist_leaves <- as.matrix(dist(leaf_coors))
  
  group_leaves_l <- lapply(1:nrow(centers), function(x){
    
    dists_to_center <- dist_leaves[centers$leaves[x], ]
    
# Se seleccionan las hojas  cuya distancia al centro sea menor que el tamaño del grupo multiplicado por un radio constante,  
    selec_leaves <- dists_to_center[dists_to_center < centers$group_size[x] * radius_constant] 
    
# Se crea un data frame de las hojas selecionadas y sus respectivas coordenadas 
    selec_leaves_df <- leaf_coors[names(selec_leaves), ]
    
    selec_leaves_df$leaf_id <- names(selec_leaves)
    
    selec_leaves_df$dist_to_center <- selec_leaves
    
    selec_leaves_df$group_size <- centers$group_size[x]
    
    selec_leaves_df$id <- x
    
    return(selec_leaves_df)
    
  })
  group_leaves <- do.call(rbind, group_leaves_l)
  
 return(group_leaves)
}
```

### Ámbitos de descanso

Función:
```{r}
#Función para obtener  determinar estimar los ámbitos de descanso para cada grupo,  con un 95% de confianza .

get_home_range <- function(X, percent = 95){
  
  Y <- SpatialPointsDataFrame(X[, c("lat", "lon")], as.data.frame(X$id))

  ud <- try(kernelUD(Y), silent = TRUE)
  
  areas <- unlist(as.data.frame(kernel.area(ud, percent = percent))[1,, drop = TRUE])
  
  areas_df <- data.frame(group = 1:length(areas), area = areas, group_size = sapply(unique(X$id), function(e) X$group_size[X$id == e][1]))

  return(areas_df)
}


### Esta  funcion es para  haces  un submuestreo y confirmar  si  el resultado  mantiene  el mismo patron 
resample_leaves <- function(X, n = 30){
  
  out <- lapply(unique(X$id), function(x){
    
    Y <- X[X$id == x, ]
    
    if (nrow(Y) > n) 
      Y <- Y[sample(1:nrow(Y), n), ]
    
    return(Y)
    
  })
  
  return(do.call(rbind, out))
  
}
```

Estimación de ámbitos de descanso 

```{r}
# Se asume que las  coordenadas simuladas son hojas utilizadas  por los grupos (ubicación de grupos en refugios) 

leaf_coors <- sim_habitat(n_leaves = 1000, plot = FALSE)

sims <- ubi_groups(leaf_coors = leaf_coors, groups = 10, radius_constant = 6)

tab <- table(sims$id)
## Esto es para obtener el numero de hojas  que  hay en cada territorio 
sims <- sims[!sims$id %in% names(tab[tab < 5]), ]

#  Se crea un set de datos  que contiene el área del ámbito de descanso y el numero de individuos para cada grupo 

range_and_size <- get_home_range(X = sims)
```

# Análisis  

Para ver  el efecto  que tiene  el tamalo  del grupo  sobre el tamaño de los ambitos de descanso, se realizo un modelo lineal 

```{r, echo= FALSE, fig.align='center'}
mod <- lm(area ~ group_size, data = range_and_size)
summary(mod)

#plot(range_and_size$group_size, range_and_size$area)

#abline(mod, col = "red")

ggplot(range_and_size, aes(group_size, area)) +
 geom_point(aes(group_size, area)) +
 geom_smooth(method ="lm") +
 xlab("Número de individuos") + 
 ylab("Tamaño del ámbito de descanso") +
 scale_color_gradient() +
 theme_bw()
```

Luego  

```{r}
resamp_sims <- resample_leaves(sims, n = 45)


table(resamp_sims$id)

#  
resample_range_and_size <- get_home_range(X = resamp_sims)


mod2 <- lm(area ~ group_size, data = resample_range_and_size)
summary(mod2)

#plot(resample_range_and_size$group_size, resample_range_and_size$area)

#abline(mod2, col = "red")

ggplot(resample_range_and_size, aes(group_size, area)) +
 geom_point(aes(group_size, area)) +
 geom_smooth(method ="lm") +
 xlab("Número de individuos") + 
 ylab("Tamaño del ámbito de descanso") +
 scale_color_gradient() +
 theme_bw()
```

```{r}

 
  # dist_leaves[dist_leaves == 0] <- NA
  # 
  # sel_leaf <- 1
  # 
  # 
  # group_size <- rbinom(30, 10, 0.5) + 1
  # group_range_prob <- (group_size / max(group_size)) / 4
  # 
  # groups <- 10
  # cols <- viridis::viridis(groups, alpha = 0.6)
  # 
  # for(e in 1:10){
  # 
  #   if (e == 1)
  #   sl <- sel_leaf <- sample(1:nrow(leaf_coors), 1) else {
  # 
  #     disp_leaves <- dist_leaves[sel_leaf, ]
  #     disp_leaves <- disp_leaves[disp_leaves > quantile(disp_leaves, 0.1, na.rm = TRUE)]
  # 
  #     sl <- sel_leaf <- sample(names(disp_leaves), 1)
  #     }
  # 
  #   # initial group leaf
  #   points(leaf_coors[sel_leaf, ], pch = 20, cex = 5, col = adjustcolor("white", alpha.f = 0.8))
  #   text(leaf_coors[sel_leaf, ], labels = e, cex = 2, adj = c(0.5, 0.5))
  # 
  #   for(i in 1:29){
  # 
  #     disp_leaves <- dist_leaves[sel_leaf, ]
  #     disp_leaves <- disp_leaves[disp_leaves < quantile(disp_leaves, group_range_prob[e] , na.rm = TRUE)]
  # 
  #     sel_leaf <- NA
  #     while(is.na(sel_leaf))
  #     sel_leaf <- picked_leave <- sample(names(disp_leaves), 1)
  # 
  #   # picked_leave <- sample(names(sort(dist_leaves[sel_leaf, ]))[1:30], 1)
  # 
  #   points(leaf_coors[picked_leave,], col = cols[e])
  # 
  #  # sel_leaf <- picked_leave
  #   }
  #   # initial group leaf
  #   points(leaf_coors[sl, ], pch = 20, cex = 5, col = adjustcolor("white", alpha.f = 0.5))
  #   text(leaf_coors[sl, ], labels = e, cex = 2, adj = c(0.5, 0.5), col = "gray40")
  # 
  # Sys.sleep(0.1)
  #   }


```
# Referencias 

```{r  include=FALSE}
sessionInfo()
```